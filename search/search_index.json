{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"Tim Desanti Datasheet as part of  Temperature Equalizing Blinds for  Team 105  <p>Submission: October 31, 2025 </p><p></p>","tags":["tag1","tag2"]},{"location":"#introduction","title":"Introduction","text":"<p>The Temperature Equalizing Blinds system is designed to automatically regulate room temperature by adjusting the position of window blinds in response to ambient conditions. Using a temperature sensor, the system detects heat variations and actuates a small 12 V DC motor, controlled through an H-bridge driver, to open or close the slats of the blinds. The goal is to maintain thermal balance by minimizing excessive sunlight during hot conditions and maximizing natural warmth during cooler periods.</p>","tags":["tag1","tag2"]},{"location":"#project-summary","title":"Project Summary","text":"<p>The motor control subsystem operates a small 12 V DC brushed motor through an H-Bridge driver (FAN8100N) to open and close the blinds. Controlled by the PIC18F57Q43 Curiosity Nano, it uses PWM signals to regulate motor speed and direction for smooth movement. A 9\u201312 V DC power source supplies the system, with voltage regulated to 5 V for control electronics. The design includes a status LED and connector interface for integration with the temperature sensing and main control modules.</p>","tags":["tag1","tag2"]},{"location":"#my-contribution","title":"My Contribution","text":"<p>My part of the project focuses on designing and constructing the motor control subsystem that physically opens and closes the blinds based on input from the main control unit. It will rely on the other subsystems to determine how it will operate.</p> <p>To review the details listed of the material used to construct the subsection, you can review it in the https://timdesanti.github.io/03-BOM/BOM/ section of the datasheet. </p> <p>For all the sections</p>","tags":["tag1","tag2"]},{"location":"01-Block-Diagram/Block-Diagram/","title":"Individual Block Diagram for Slat Motor","text":""},{"location":"01-Block-Diagram/Block-Diagram/#overview","title":"Overview","text":"<p>This block diagram illustrates the system architecture for controlling a DC motor using the Microchip PIC18F57Q43 Curiosity Nano board. It shows how power, sensing, and actuation are distributed throughout the system. A 12V 3A unregulated power supply provides the main power, which is regulated to 12V (1.5A) for the microcontroller and control electronics. An analog sensor connected to the ADC input (RA0) provides input signals for feedback or control. The H-Bridge (FAN8100N) drives the motor (actuator) using PWM signals from the microcontroller. Green LED to check if power is going through the system. It translates to a motor that will open and close the blinds depending on the signals given from the other components.</p>"},{"location":"01-Block-Diagram/Block-Diagram/#motor-pcb-block-diagram","title":"Motor PCB Block Diagram","text":"<p>Individual Block EGR304 TND (1).drawio </p>"},{"location":"02-Component-Selection/Component-Selection/","title":"Component Selection Tim Desanti 105","text":""},{"location":"02-Component-Selection/Component-Selection/#dc-motor","title":"DC Motor","text":"<ol> <li>GEARMOTOR 35 RPM 12V MIRCO METAL</li> </ol> <ul> <li>$37.95/each  </li> <li>Link to product</li> </ul> Pros Cons 12v Expensive Small in size Might be too slow High torque Size may not be as compact as wanted <ol> <li>GEARMOTOR 200 RPM 3\u20136V DC</li> </ol> <ul> <li>$2.95/each  </li> <li>Link to product</li> </ul> Pros Cons Low voltage use More expensive Compact Weak Simple wiring Low RPM <ol> <li>SERVOMOTOR RC 4.8V</li> </ol> <ul> <li>$3.62/each  </li> <li>Link to product</li> </ul> Pros Cons Quick response time Requires programming Precise movement Moderately expensive Programmable to move to set positions Requires more voltage <p>Choice: Option 1 \u2014 GEARMOTOR 35 RPM 12V MICRO METAL</p> <p>Rationale: Requires fewer programs to be made. It will rely on the sensors to function, which is what we want. Provides enough power to run its function at a reasonable cost. High Torque.</p>"},{"location":"02-Component-Selection/Component-Selection/#h-bridge-motor","title":"H-Bridge Motor","text":"<ol> <li>IC MOTOR DRIVER 12V-52V 24SO</li> </ol> <ul> <li>$6.16/each  </li> <li>Link to product     | Pros                      | Cons                                                             |    | -------------------------- | ---------------------------------------------------------------- |    | Inexpensive                | Requires external components and support circuitry               |    | For large voltage    |      complicated configuration                                                          |    | 12V             | surface mount                                    |</li> </ul> <ol> <li>L9110H H-BRIDGE 8DIP MOTOR DRIVE</li> </ol> <ul> <li>$1.50/each  </li> <li>Link to product</li> </ul> Pros Cons Inexpensive Requires external components and support circuitry easy to set up can only run 1 motor 8-dip <ol> <li>IC MTR DRV BIPLR 12-55V TO220-11</li> </ol> <ul> <li>$28.26/each  </li> <li>Link to product</li> </ul> Pros Cons ECAD Expensive 12V-55V Complicated wiring Can run 2 different motors Fixed output voltage <p>Choice: Option 2 - L9110H H-BRIDGE 8DIP MOTOR DRIVE</p> <p>Rationale: A simple H-bridge for 1 motor, which is being used for the system. Easier to wire up and to code. Small and inexpensive, great for simple coding and space constraints. </p>"},{"location":"02-Component-Selection/Component-Selection/#overview-summary","title":"Overview Summary","text":"<p>Microchip PIC18F57Q43 Curiosity Nano, Analog Input Sensor, Green LED, and Connectors are parts that were given and worked on in class. The only unfamiliar part would be the DC motor and the H-Bridge, as they are not familiar components but are used in the same way as components we have worked on in the classroom.</p>"},{"location":"03-BOM/BOM/","title":"BOM","text":"<p>BOMschematic design.csv--- title: Bill of Materials tags: - tag1 - tag2</p>"},{"location":"03-BOM/BOM/#overview","title":"Overview","text":"<p>All listed parts and their pricing, quantity, datasheet, part numbers, data sheet, and where to purchase the items. For context: \"n/a\" is labeled as given parts supplied from ASU for classroom purposes that will be repurposed for this project.</p>"},{"location":"03-BOM/BOM/#bill-of-materials","title":"Bill of Materials","text":"<p>Bill of Materials for the schematic can be seen here:  BOMschematic design.csv</p> <p>The Excel BOM sheet can be seen here. Bill of Materials .xlsx</p>"},{"location":"04-Schematic/schematic/","title":"Schematic Design","text":""},{"location":"04-Schematic/schematic/#overview","title":"Overview","text":"<p>This schematic is designed to allow a motor to open and close the blinds based on the readings of the thermo sensor, light sensor(s), and distance sensor that determine whether the blinds should be open or closed, and stop if there is an object preventing them from closing all the way. </p> <p>Figure 01:</p> <p></p>"},{"location":"04-Schematic/schematic/#resouces","title":"Resouces","text":"<p>The schematic as PDF is downloadable, Schematic design_V2.pdf</p> <p>, and the Zip folder of the project, MotorSchematicDesign.zip</p>"},{"location":"05-Power-Budget/Power-Budget/","title":"Power Budget","text":""},{"location":"05-Power-Budget/Power-Budget/#overview","title":"Overview","text":"<p>Calculated the voltage and current usage for the chosen components. Gave a voltage budget of how much current the components would need and show the remaining current when choosing a power supply. The chosen components were the PIC18F57Q43 microcontroller, GEAR MOTOR 12V 34RPM, and a IC REG LINEAR 5V 1.5A TO220 voltage regulator.</p> <p> </p>"},{"location":"05-Power-Budget/Power-Budget/#conclusions","title":"Conclusions","text":"<p>From the prepared Power Budget, we would need a 12V power source and a 12V power rail to allow the parts to function properly. The budget is mostly budget-friendly voltage-wise, besides the 12V regulator and motor that will consume more electricity. I believe using a wall adapter will solve this problem, other than using a battery to increase its duration, and using an external battery as a backup source if the power shuts down in the home.  </p>"},{"location":"05-Power-Budget/Power-Budget/#resouces","title":"Resouces","text":"<p>The power budget as a PDF download is available here, Power Budget Example.pdf</p> <p>, and a Microsoft Excel Sheet here, Power Budget Example.xlsx</p>"},{"location":"06-PCB-Design/PCB-Design/","title":"PCB Design","text":""},{"location":"06-PCB-Design/PCB-Design/#overview","title":"Overview","text":"<p>This PCB design includes all components from the schematic. The motor will have female header pins to allow a custom length from the board to its final location. Additionally, the microcontroller footprint will also have female headers, as it was already constructed due to breadboarding.</p> <p>PCB Front Layer: </p> <p>PCB Back Layer: </p> <p>Front &amp; Back.pdf</p> <p>ZIP File With Footprints</p> <p>GERBER_Files.zip</p>"},{"location":"07-Microcontroller-Code/07-Microcontroller-Code/","title":"Individal Subsystem code for the PIC microcontroller","text":"","tags":["tag1","tag2"]},{"location":"07-Microcontroller-Code/07-Microcontroller-Code/#overview","title":"Overview","text":"","tags":["tag1","tag2"]},{"location":"07-Microcontroller-Code/07-Microcontroller-Code/#_1","title":"Individal Subsystem code for the PIC microcontroller","text":"<p>Following is the code for the motor of the blinds to operate based off the input singal given from thew other subsystems. Autogenerated files and the MCC Melody configuration can be downloaded in the project package. </p><pre><code>/**\n * PIC18F57Q43 H-Bridge Motor Controller with PWM\n * Motor: Pololu 12V Micro Metal Gearmotor 35 RPM\n * \n * Pin Configuration:\n * - RC5: Button Input (press to toggle direction)\n * - RF5: MOTOR_PLUS - PWM output to H-bridge (forward direction)\n * - RF6: MOTOR_MINUS - PWM output to H-bridge (reverse direction)\n * - RD7: Debug LED\n * - RF1: Debug Button\n * \n * MCC Custom Pin Names:\n * - RF5 is named \"MOTOR_PLUS\" in MCC\n * - RF6 is named \"MOTOR_MINUS\" in MCC\n * \n * Operation:\n * - Press RC5 (1st time): Motor runs FORWARD while button is held\n * - Release RC5: Motor STOPS\n * - Press RC5 (2nd time): Motor runs REVERSE while button is held\n * - Release RC5: Motor STOPS\n * - Press RC5 (3rd time): Back to FORWARD\n * - Cycle repeats...\n */\n\n#include \"mcc_generated_files/system/system.h\"\n\n//=============================================================================\n// PIN INPUT/OUTPUT DEFINITIONS\n//=============================================================================\n\n// INPUT: Read button signal from RC5\n#define BUTTON_READ()       PORTCbits.RC5\n\n// OUTPUT: Control debug LED on RD7\n#define DEBUG_LED_ON()      LATDbits.LATD7 = 1\n#define DEBUG_LED_OFF()     LATDbits.LATD7 = 0\n\n// INPUT: Read debug button on RF1\n#define DEBUG_BUTTON_READ() PORTFbits.RF1\n\n//=============================================================================\n// PWM CONTROL - Using MCC Generated Functions\n//=============================================================================\n\n// PWM OUTPUT on RF5 (MOTOR_PLUS) - Forward direction\n#define MOTOR_PLUS_PWM_START()      PWM1_16BIT_Enable()\n#define MOTOR_PLUS_PWM_STOP()       PWM1_16BIT_Disable()\n#define MOTOR_PLUS_PWM_SET(duty)    PWM1_16BIT_SetSlice1Output1DutyCycleRegister(duty)\n\n// PWM OUTPUT on RF6 (MOTOR_MINUS) - Reverse direction\n#define MOTOR_MINUS_PWM_START()     PWM1_16BIT_Enable()\n#define MOTOR_MINUS_PWM_STOP()      PWM1_16BIT_Disable()\n#define MOTOR_MINUS_PWM_SET(duty)   PWM1_16BIT_SetSlice1Output2DutyCycleRegister(duty)\n\n// PWM duty cycle values (0-65535 for 16-bit PWM)\n#define PWM_FULL_SPEED      65535   // 100% duty cycle = full speed\n#define PWM_STOP            0       // 0% duty cycle = stop\n\n//=============================================================================\n// MOTOR STATE TRACKING\n//=============================================================================\n\ntypedef enum {\n    DIRECTION_FORWARD = 0,    // Next press will run forward\n    DIRECTION_REVERSE         // Next press will run reverse\n} DirectionMode_t;\n\n// Global variables\nvolatile DirectionMode_t nextDirection = DIRECTION_FORWARD;\nvolatile uint8_t lastButtonState = 1;  // Assume button not pressed initially (HIGH with pull-up)\nvolatile uint8_t motorRunning = 0;     // Track if motor is currently running\nvolatile uint16_t ledBlinkCounter = 0; // Counter for LED blinking\n\n//=============================================================================\n// FUNCTION DECLARATIONS\n//=============================================================================\n\nvoid Motor_Forward(void);\nvoid Motor_Reverse(void);\nvoid Motor_Stop(void);\nvoid Debug_UpdateLED(void);\n\n//=============================================================================\n// MAIN PROGRAM\n//=============================================================================\n\nint main(void)\n{\n    //=========================================================================\n    // INITIALIZATION - Run once at startup\n    //=========================================================================\n\n    // Initialize all MCC configured peripherals (PWM, pins, clock, etc.)\n    SYSTEM_Initialize();\n\n    // Configure RC5 as input if not done in MCC\n    TRISCbits.TRISC5 = 1;      // Input\n    ANSELCbits.ANSELC5 = 0;    // Digital\n    WPUCbits.WPUC5 = 1;        // Enable weak pull-up\n\n    // Start with motor stopped\n    Motor_Stop();\n\n    // Flash LED 3 times to show system is ready\n    for(uint8_t i = 0; i &lt; 3; i++)\n    {\n        DEBUG_LED_ON();\n        __delay_ms(100);\n        DEBUG_LED_OFF();\n        __delay_ms(100);\n    }\n\n    //=========================================================================\n    // MAIN LOOP - Runs continuously forever\n    //=========================================================================\n\n    while(1)\n    {\n        //=====================================================================\n        // INPUT: Read button signal from RC5\n        //=====================================================================\n        uint8_t currentButtonState = BUTTON_READ();  // Read RC5 pin (0 or 1)\n\n        //=====================================================================\n        // BUTTON PRESSED (HIGH signal or button active)\n        //=====================================================================\n        if(currentButtonState == 1)  // Button is pressed (receiving signal)\n        {\n            // Check if this is a NEW button press (rising edge)\n            if(lastButtonState == 0 &amp;&amp; currentButtonState == 1)\n            {\n                // This is a new press - toggle direction\n                if(nextDirection == DIRECTION_FORWARD)\n                {\n                    nextDirection = DIRECTION_REVERSE;  // Next will be reverse\n                }\n                else\n                {\n                    nextDirection = DIRECTION_FORWARD;  // Next will be forward\n                }\n                __delay_ms(50);  // Debounce delay\n            }\n\n            // OUTPUT: Run motor in the current direction while button is held\n            if(nextDirection == DIRECTION_FORWARD)\n            {\n                Motor_Forward();       // Run motor forward\n                motorRunning = 1;      // Motor is running forward\n            }\n            else  // nextDirection == DIRECTION_REVERSE\n            {\n                Motor_Reverse();       // Run motor reverse\n                motorRunning = 2;      // Motor is running reverse\n            }\n        }\n        //=====================================================================\n        // BUTTON RELEASED (LOW signal - no signal received)\n        //=====================================================================\n        else  // currentButtonState == 0\n        {\n            // OUTPUT: Stop motor immediately when button is released\n            Motor_Stop();\n            motorRunning = 0;  // Motor is stopped\n        }\n\n        // Update last button state for edge detection\n        lastButtonState = currentButtonState;\n\n        //=====================================================================\n        // DEBUG: Update LED based on motor state\n        //=====================================================================\n        Debug_UpdateLED();\n        ledBlinkCounter++;  // Increment counter for LED blinking\n\n        //=====================================================================\n        // TIMING: Small delay before next loop iteration\n        //=====================================================================\n        __delay_ms(10);  // 10ms delay\n    }\n\n    return 0;\n}\n\n//=============================================================================\n// MOTOR CONTROL FUNCTIONS\n//=============================================================================\n\n/**\n * MOTOR FORWARD FUNCTION\n * \n * OUTPUT: Sets PWM signals to H-bridge for forward rotation\n * \n * H-Bridge Logic:\n * - RF5 (MOTOR_PLUS) = PWM at full speed (HIGH pulses)\n * - RF6 (MOTOR_MINUS) = Constant LOW (MUST be disabled)\n * \n * This creates forward rotation\n */\nvoid Motor_Forward(void)\n{\n    // CRITICAL: First stop RF6 to prevent both outputs being active\n    MOTOR_MINUS_PWM_STOP();              // Disable RF6 completely\n    MOTOR_MINUS_PWM_SET(0);              // Set RF6 duty to 0%\n\n    // Then start RF5 for forward\n    MOTOR_PLUS_PWM_SET(PWM_FULL_SPEED);  // Set RF5 to 100% duty cycle\n    MOTOR_PLUS_PWM_START();              // Enable PWM output on RF5\n}\n\n/**\n * MOTOR REVERSE FUNCTION\n * \n * OUTPUT: Sets PWM signals to H-bridge for reverse rotation\n * \n * H-Bridge Logic:\n * - RF5 (MOTOR_PLUS) = Constant LOW (MUST be disabled)\n * - RF6 (MOTOR_MINUS) = PWM at full speed (HIGH pulses)\n * \n * This creates reverse rotation\n */\nvoid Motor_Reverse(void)\n{\n    // CRITICAL: First stop RF5 to prevent both outputs being active\n    MOTOR_PLUS_PWM_STOP();               // Disable RF5 completely\n    MOTOR_PLUS_PWM_SET(0);               // Set RF5 duty to 0%\n\n    // Then start RF6 for reverse\n    MOTOR_MINUS_PWM_SET(PWM_FULL_SPEED); // Set RF6 to 100% duty cycle\n    MOTOR_MINUS_PWM_START();             // Enable PWM output on RF6\n}\n\n/**\n * MOTOR STOP FUNCTION\n * \n * OUTPUT: Stops motor by disabling both PWM outputs\n * \n * H-Bridge Logic:\n * - RF5 (MOTOR_PLUS) = LOW\n * - RF6 (MOTOR_MINUS) = LOW\n * \n * This creates: No voltage differential \u2192 Motor stops (coasts)\n */\nvoid Motor_Stop(void)\n{\n    // OUTPUT: Disable both PWM outputs and set duty to 0\n    MOTOR_PLUS_PWM_STOP();    // Disable RF5\n    MOTOR_PLUS_PWM_SET(0);    // Set RF5 duty to 0%\n\n    MOTOR_MINUS_PWM_STOP();   // Disable RF6\n    MOTOR_MINUS_PWM_SET(0);   // Set RF6 duty to 0%\n}\n\n//=============================================================================\n// NOTES AND EXPLANATIONS\n//=============================================================================\n\n/*\n * OPERATION SUMMARY:\n * \n * The motor operates based on button presses and releases:\n * \n * 1. Press button (RC5 = 1): Motor runs in current direction (Forward or Reverse)\n * 2. Release button (RC5 = 0): Motor STOPS\n * 3. Next press: Motor runs in opposite direction\n * \n * Example sequence:\n * - Press \u2192 FORWARD \u2192 Release \u2192 STOP\n * - Press \u2192 REVERSE \u2192 Release \u2192 STOP\n * - Press \u2192 FORWARD \u2192 Release \u2192 STOP\n * - And so on...\n * \n * \n * INPUT vs OUTPUT:\n * \n * INPUT (Reading):\n * - RC5: BUTTON_READ() detects if button is pressed (1) or released (0)\n * \n * OUTPUT (Writing):\n * - RF5 (MOTOR_PLUS): PWM signal for forward direction\n * - RF6 (MOTOR_MINUS): PWM signal for reverse direction\n * - RD7: LED indicates forward (ON) or reverse (OFF)\n * \n * \n * EDGE DETECTION:\n * \n * The code uses \"edge detection\" to determine when the button is released:\n * - lastButtonState = previous state of button\n * - currentButtonState = current state of button\n * - When lastButtonState=1 AND currentButtonState=0 \u2192 Button just released\n * - This triggers the direction toggle for the next press\n */\n\n/**\n * DEBUG LED UPDATE FUNCTION\n * \n * Updates the debug LED (RD7) with different blink patterns based on motor state:\n * - FORWARD: Fast blink (mostly ON)\n * - REVERSE: Medium blink (equal ON/OFF)\n * - STOP: Slow blink (mostly OFF)\n */\nvoid Debug_UpdateLED(void)\n{\n    if(motorRunning == 1)  // Motor running FORWARD\n    {\n        // Fast blink - LED mostly ON\n        if(ledBlinkCounter % 20 &lt; 15)  // ON for 15 cycles, OFF for 5\n        {\n            DEBUG_LED_ON();\n        }\n        else\n        {\n            DEBUG_LED_OFF();\n        }\n    }\n    else if(motorRunning == 2)  // Motor running REVERSE\n    {\n        // Medium blink - Equal ON/OFF\n        if(ledBlinkCounter % 40 &lt; 20)  // ON for 20 cycles, OFF for 20\n        {\n            DEBUG_LED_ON();\n        }\n        else\n        {\n            DEBUG_LED_OFF();\n        }\n    }\n    else  // motorRunning == 0, Motor STOPPED\n    {\n        // Slow blink - LED mostly OFF\n        if(ledBlinkCounter % 100 &lt; 10)  // ON for 10 cycles, OFF for 90\n        {\n            DEBUG_LED_ON();\n        }\n        else\n        {\n            DEBUG_LED_OFF();\n        }\n    }\n}\n</code></pre><p></p>","tags":["tag1","tag2"]},{"location":"07-Microcontroller-Code/07-Microcontroller-Code/#zip-of-code","title":"Zip of code","text":"<p>The MPLAB IDE project is available here.</p>","tags":["tag1","tag2"]}]}